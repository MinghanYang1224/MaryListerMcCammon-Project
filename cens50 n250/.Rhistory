setwd("/Users/FJRubio/Dropbox/ODESurv/Codes/Simulations/HT/cens50/n250")
#######################################################################################
# Data preparation
#######################################################################################
rm(list=ls())
# Required packages
library(deSolve)
library(survival)
library(ggplot2)
#library(devtools)
#install_github("FJRubio67/HazReg")
library(HazReg)
library(Rtwalk)
library(spBayes)
library(knitr)
library(demography)
## ----include=FALSE----------------------------------------------------------------------------------------
#source("C:/Users/Javier/Dropbox/ODESurv/Codes/routines/routines.R")
source("/Users/FJRubio/Dropbox/ODESurv/Codes/routines/routines.R")
## ----eval=FALSE-------------------------------------------------------------------------------------------
## source("routines.R")
## ---------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------
# Data preparation
#--------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------
# Parameter values
lambda <- 1.8
kappa <- 0.1
alpha <- 6
beta <- 4.8
h0 <- 1e-2
q0 <- 1e-6
truepar <- c(lambda, kappa, alpha, beta)
# Sample size
n <- 250
# Censoring time
cens <- 11
# Simulation specifications
nsim <- 250 # number of Monte Carlo simulations
NMC <- 55000 # number of MCMC iterations
burn <- 5000 # burn-in period
thin <- 50 # thinning period
# Posterior sample after burn-in and thinning
ind=seq(burn,NMC,thin)
postHT <- list()
for(j in 1:nsim){
print(j)
# Data simulation
set.seed(j)
sim <- simHT(n = n, par = truepar, tmin = 0, tmax = 150, step = 1e-3)$sim
status <- ifelse(sim < cens, 1, 0)
time <- ifelse(sim < cens, sim, cens)
# New data frame: logical status, time in years, survival times sorted
df <- data.frame(time = time, status = status)
df$status <- as.logical(df$status)
df <- df[order(df$time),]
# Required quantities
status <- as.logical(df$status)
t_obs <- df$time[status]
survtimes <- df$time
#==================================================================================================
# Bayesian Analysis
#==================================================================================================
# Initial point
# Optimisation step
OPTHT <- nlminb(log(truepar[1:4]) , log_likHTL, control = list(iter.max = 10000))
#--------------------------------------------------------------------------------------------------
# Hazard-Treatment ODE model for the hazard function: Solver solution
#--------------------------------------------------------------------------------------------------
n.batch <- 1100
batch.length <- 50
lp <- function(par) -log_postHTL(par)
inits <- OPTHT$par
set.seed(j)
infoHT <- adaptMetropGibbs(ltd=lp, starting=inits, accept.rate=0.44, batch=n.batch,
batch.length=batch.length, report=100, verbose=FALSE)
chainHT <- infoHT$p.theta.samples[,1:4]
# Burning and thinning the chain
burn <- 5000
thin <- 50
NS <- n.batch*batch.length
ind <- seq(burn,NS,thin)
postHT[[j]] <- exp(chainHT[ind,1:4])
}
#setwd("~/Dropbox/ODESurv/Codes/Simulations/HT/cens50/n250")
setwd("C:/Users/Javier/Dropbox/ODESurv/Codes/Simulations/HT/cens50/n250")
#setwd("~/Dropbox/ODESurv/Codes/Simulations/HT/cens50/n250")
setwd("/Users/FJRubio/Dropbox/ODESurv/Codes/Simulations/HT/cens50/n250")
save.image("HTn250c50.RData")
library(xtable)
truepar0 <- truepar[1:4]
# Posterior mean
postMean <- matrix(0, ncol = 4, nrow = nsim)
for(i in 1:nsim) postMean[i,] <- colMeans(postHT[[i]])
# Posterior median
postMedian <- matrix(0, ncol = 4, nrow = nsim)
for(i in 1:nsim) postMedian[i,] <- apply(postHT[[i]],2,median)
# Posterior sd
postSD <- matrix(0, ncol = 4, nrow = nsim)
for(i in 1:nsim) postSD[i,] <- apply(postHT[[i]],2,sd)
# RMSE for the Posterior mean
RMSEMean <- sqrt(colMeans(sweep(postMean ,2, truepar, FUN="-")^2))
# Coverage of 95% credible intervals
cover <- matrix(0, ncol = 4, nrow = nsim)
for(i in 1:nsim){
for(j in 1:5){
CIL <- quantile(postHT[[i]][,j], 0.025)
CIU <- quantile(postHT[[i]][,j], 0.975)
cover[i,j] <- ifelse( CIL < truepar0[j] & truepar0[j] < CIU, 1, 0)
}
}
# Coverage of 95% credible intervals
cover <- matrix(0, ncol = 4, nrow = nsim)
for(i in 1:nsim){
for(j in 1:4){
CIL <- quantile(postHT[[i]][,j], 0.025)
CIU <- quantile(postHT[[i]][,j], 0.975)
cover[i,j] <- ifelse( CIL < truepar0[j] & truepar0[j] < CIU, 1, 0)
}
}
tab <- cbind(colMeans( postMean),
colMeans( postMedian),
colMeans(postSD),
RMSEMean,
colMeans(cover))
Greeks <- c("$\\lambda$","$\\kappa$","$\\alpha$","$\\beta$")
rnames <- paste0(Greeks, " (", truepar0, ")")
rownames(tab) <- rnames
print(xtable(tab,digits=3), include.colnames = F, sanitize.rownames.function = identity)
#######################################################################################
# Data preparation
#######################################################################################
rm(list=ls())
# Required packages
library(deSolve)
library(survival)
library(ggplot2)
#library(devtools)
#install_github("FJRubio67/HazReg")
library(HazReg)
library(Rtwalk)
library(spBayes)
library(knitr)
library(demography)
library(bshazard)
library(splines)
## ----include=FALSE----------------------------------------------------------------------------------------
source("~/Dropbox/ODESurv/ODESurv/Codes/routines/routines.R")
load("HTn250c50.RData")
## ----eval=FALSE-------------------------------------------------------------------------------------------
## source("routines.R")
## ---------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------
# Data preparation
#--------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------
# Parameter values
lambda <- 1.8
kappa <- 0.1
alpha <- 6
beta <- 4.8
h0 <- 1e-2
q0 <- 1e-6
truepar <- c(lambda, kappa, alpha, beta)
# Sample size
n <- 250
# Censoring time
cens <- 11
# Simulation specifications
nsim <- 250 # number of Monte Carlo simulations
# Time grid
tvec <- seq(0,cens,by = 0.1)
ntvec <- length(tvec)
NMCMC <- nrow(postHT[[1]]) # number of MCMC samples
distbs <- vector()
distp <- vector()
################################################################################################
# True hazard
################################################################################################
# Hazard-Response
paramsHRT  <- c(lambda = truepar[1], kappa = truepar[2], alpha = truepar[3],
beta = truepar[4])
initHRT      <- c(h = h0, q = q0, H = 0 )
outT <- ode(initHRT, tvec, hazmodHR, paramsHRT, method = "lsode", jacfunc = jacODE, jactype = "fullusr")
hT <- outT[,2]
################################################################################################
# Simulation
################################################################################################
for(j in 1:nsim){
print(j)
# Data simulation
set.seed(j)
sim <- simHT(n = n, par = truepar, tmin = 0, tmax = 150, step = 1e-3)$sim
status <- ifelse(sim < cens, 1, 0)
time <- ifelse(sim < cens, sim, cens)
# New data frame: logical status, time in years, survival times sorted
df <- data.frame(time = time, status = status)
df$status <- as.logical(df$status)
df <- df[order(df$time),]
# Required quantities
status <- as.logical(df$status)
t_obs <- df$time[status]
survtimes <- df$time
#--------------------------------------------------------------------------------------
# B-splines model
#--------------------------------------------------------------------------------------
fit <- bshazard(Surv(df$time, as.numeric(df$status)) ~ 1, data = df, nbin = ntvec, verbose = FALSE)
#--------------------------------------------------------------------------------------
# Hazard-Response model
#--------------------------------------------------------------------------------------
hCIHR <- matrix(0, ncol = ntvec, nrow = NMCMC)
chCIHR <- matrix(0, ncol = ntvec, nrow = NMCMC)
SCIHR <- matrix(0, ncol = ntvec, nrow = NMCMC)
qCIHR <- matrix(0, ncol = ntvec, nrow = NMCMC)
for(k in 1:NMCMC){
paramsHRj  <- c(lambda = postHT[[j]][k,1], kappa = postHT[[j]][k,2], alpha = postHT[[j]][k,3],
beta = postHT[[j]][k,4])
initHRj      <- c(h = h0, q = q0, H = 0 )
outj <- ode(initHRj, tvec, hazmodHR, paramsHRj, method = "lsode", jacfunc = jacODE, jactype = "fullusr")
hCIHR[k, ] <- outj[,2]
qCIHR[k, ] <- outj[,3]
chCIHR[k, ] <- outj[,4]
SCIHR[k, ] <- exp(-outj[,4])
}
numHR <- hCIHR*exp(-chCIHR)
denHR <- exp(-chCIHR)
hpredHR <- colMeans(numHR)/colMeans(denHR)
#--------------------------------------------------------------------------------------
# Distances
#--------------------------------------------------------------------------------------
bsh <- Vectorize(function(t) splinefun(x = fit$time, y = fit$hazard)(t))
hts <- Vectorize(function(t) splinefun(tvec, hT)(t))
hps <- Vectorize(function(t) splinefun(tvec, hpredHR)(t))
difbs <- Vectorize(function(t) abs(bsh(t) - hts(t)))
difp <- Vectorize(function(t) abs(hps(t) - hts(t)))
distbs[j] <- integrate(difbs, 0.001, cens)$value
distp[j] <- integrate(difp, 0.001, cens)$value
}
#setwd("~/Dropbox/ODESurv/Codes/Simulations/HT/cens50/n250")
setwd("~/Dropbox/ODESurv/ODESurv/Codes/Simulations/HT/cens50/n250")
save.image("HTn250c50_comparison.RData")
library(ggplot2)
df <- reshape2::melt(data.frame(cbind(distp,distbs)), id.vars = NULL)
vp <- ggplot(df, aes(x = variable, y = value)) +
geom_violin(scale="width",adjust = 1,width = 0.5,fill = "grey80") +
geom_boxplot(width=0.075,fatten = 3) +
theme_bw() + xlab("n = 250, 25% censoring") + ylab("Distance") +
theme(axis.text.x = element_text(size = 14), axis.text.y = element_text(size = 14)) +
theme(axis.title.x = element_text(size = 14), axis.title.y = element_text(size = 14)) +
scale_x_discrete(labels = c("Predictive", "B-Splines"))
vp
